{"version":3,"sources":["logo.svg","PathFinding/Node/Node.jsx","PathFinding/algorithms/dijkstra.js","PathFinding/algorithms/aStar.js","PathFinding/algorithms/breadthFirstSearch.js","PathFinding/algorithms/depthFirstSearch.js","PathFinding/algorithms/BestFS.js","PathFinding/mazeAlgorithms/recursiveDivsion.js","PathFinding/PathFinding.jsx","App.js","serviceWorker.js","index.js"],"names":["module","exports","Node","this","props","row","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","extraClassName","id","className","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","console","log","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","aStar","endNode","heuristic","dist","Math","abs","getRndInteger","min","max","floor","random","START_NODE_ROW","START_NODE_COL","END_NODE_ROW","END_NODE_COL","NODES_IN_COL","window","innerWidth","NODES_IN_ROW","innerHeight","PathFinding","state","mouseIsPressed","disableBtn","initializeGrid","width","height","currentRow","createNode","setState","document","getElementById","nodeType","classList","setGrid","nodesInShortestPathOrder","i","setTimeout","animateShortestPath","animations","currentNode","unshift","clearGrid","animateOuterWalls","recursiveMazeDivision","x","y","horizontal","dx","dy","wx","wy","px","py","passageBlocked","nx","ny","w","h","animateMazeBuilding","j","iswall","idName","toString","algorithm","value","clearVisitedNodes","stack","undefined","neigbors","BFS","pop","DFS","BestFS","getShortestPath","animatePathFinding","visualiseRecursiveMaze","type","algorithmName","querySelector","innerHTML","DndProvider","backend","HTML5Backend","href","Navbar","collapseOnSelect","expand","bg","variant","Toggle","aria-controls","Collapse","Nav","Form","Control","as","disabled","Button","onClick","selectMazeAlgorithm","onChange","changeBtnText","selectAlgorithm","map","rowIdx","key","style","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","handleDrop","moveNode","React","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.b9289b62.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","import React, { Component } from 'react';\r\nimport './Node.css';/*\r\nimport { DragSource, DropTarget } from 'react-dnd'\r\n\r\nlet dragable = false;\r\n\r\nconst itemSource = {\r\n  beginDrag(props){\r\n    console.log(\"dragging\");\r\n    console.log(props);\r\n    return props;\r\n  },\r\n  endDrag(props, monitor, Component){\r\n    if(!monitor.didDrop()){\r\n      //ADD FUNCTION\r\n      return;\r\n    }\r\n\r\n    return props.handleDrop(props.item);\r\n  }\r\n}\r\n\r\nfunction dragCollect(connect, monitor){\r\n  return { \r\n    connectDragSource: connect.dragSource(),\r\n    connectDragPreview: connect.dragPreview(),\r\n    isDragging: monitor.isDragging(),\r\n  }\r\n}\r\n\r\nfunction dropCollect(connect, monitor) {\r\n  return {\r\n    connectDropTarget: connect.dropTarget(),\r\n    hovered: monitor.isOver(),\r\n    item: monitor.getItem(),\r\n  }\r\n}\r\n\r\nclass Node extends Component {\r\n  render() { \r\n    const {\r\n      row,\r\n      col,\r\n      isFinish,\r\n      isStart,\r\n      isWall,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n    } = this.props; //Props are being passed over\r\n    const extraClassName = \r\n      isFinish ? 'node-finish'\r\n    : isStart ? 'node-start'\r\n    : isWall ? 'node-wall'\r\n    : '';\r\n\r\n    if(isStart || isFinish){\r\n      dragable = true;\r\n      const {\r\n        isDragging,\r\n        connectDragSource,\r\n      } = this.props;\r\n\r\n      const opacity = isDragging ? 0 : 1;\r\n\r\n      return connectDragSource(\r\n        <div\r\n          id={`node-${row}-${col}`}\r\n          className={`node ${extraClassName}`}\r\n          style={{ opacity }}\r\n          onMouseDown={() => onMouseDown(row, col)}\r\n          onMouseEnter={() => onMouseEnter(row, col)}\r\n          onMouseUp={() => onMouseUp()}></div>\r\n      );\r\n    } else {\r\n      const {\r\n        hovered,\r\n        connectDropTarget,\r\n      } = this.props;\r\n\r\n      const backgroundColor = hovered ? 'lightgreen' : 'white';\r\n      \r\n      return connectDropTarget(\r\n        <div\r\n          id={`node-${row}-${col}`}\r\n          className={`node ${extraClassName}`}\r\n          style={{ backgroundColor }}\r\n          onMouseDown={() => onMouseDown(row, col)}\r\n          onMouseEnter={() => onMouseEnter(row, col)}\r\n          onMouseUp={() => onMouseUp()}></div>\r\n      );\r\n    }\r\n\r\n  }\r\n}\r\n\r\nconst x = DropTarget(\"item\", {}, dropCollect)(Node);\r\nexport default DragSource(\"item\", itemSource, dragCollect)(x);\r\n\r\n*/\r\n\r\n//BEFORE DRAG AND DROP\r\nexport default class Node extends Component {\r\n  render() { \r\n    const {\r\n      row,\r\n      col,\r\n      isFinish,\r\n      isStart,\r\n      isWall,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n    } = this.props; //Props are being passed over\r\n    const extraClassName = \r\n      isFinish ? 'node-finish'\r\n    : isStart ? 'node-start'\r\n    : isWall ? 'node-wall'\r\n    : '';\r\n\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp()}></div>\r\n    );\r\n\r\n  }\r\n}","// Performs Dijkstra's algorithm; returns *all* nodes in the order\r\n// in which they were visited. Also makes nodes point back to their\r\n// previous node, effectively allowing us to compute the shortest path\r\n// by backtracking from the finish node.\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n\r\n  while (!!unvisitedNodes.length) { //While the array still has elements\r\n    console.log(visitedNodesInOrder);\r\n\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();\r\n\r\n    if (closestNode.isWall) continue; // If we encounter a wall, we skip it. (skips one iteration)\r\n\r\n    // If the closest node is at a distance of infinity,\r\n    // we must be trapped and should therefore stop.\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    updateUnvisitedNeighbors(closestNode, grid);\r\n\r\n  }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const {col, row} = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]); //UP\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]); //DOWN\r\n  if (col > 0) neighbors.push(grid[row][col - 1]); //LEFT\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]); //RIGHT\r\n  return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}","export function aStar(grid, startNode, endNode){\r\n    const visitedNodesInOrder = [];\r\n    startNode.distance = 0;\r\n    const unvisitedNodes = getAllNodes(grid);\r\n\r\n    while (!!unvisitedNodes.length) {\r\n        \r\n        sortNodesByDistance(unvisitedNodes, endNode);\r\n        const closestNode = unvisitedNodes.shift();\r\n\r\n        if(closestNode.isWall) continue;\r\n\r\n        if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n\r\n        closestNode.isVisited = true;\r\n        visitedNodesInOrder.push(closestNode);\r\n        if (closestNode === endNode) return visitedNodesInOrder;\r\n        updateUnvisitedNeighbors(closestNode, grid);\r\n\r\n    }\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n    const nodes = [];\r\n    for (const row of grid) {\r\n        for (const node of row) {\r\n        nodes.push(node);\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes, endNode) {\r\n    unvisitedNodes.sort((nodeA, nodeB) => (nodeA.distance + heuristic(nodeA, endNode)) - (nodeB.distance + heuristic(nodeB, endNode)));\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n    for (const neighbor of unvisitedNeighbors) {\r\n        neighbor.distance = node.distance + 1;\r\n        neighbor.previousNode = node;\r\n    }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const {col, row} = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    return neighbors.filter(neighbor => !neighbor.isVisited && !neighbor.isWall);\r\n  }\r\n\r\n//Im basing the heuristic of the distance from the node Im \r\n//looking at to where its trying to go\r\nfunction heuristic(node, endNode){\r\n    let dist = 0;\r\n\r\n    dist += Math.abs(node.col - endNode.col);\r\n    dist += Math.abs(node.row - endNode.row);\r\n\r\n    return dist;\r\n}\r\n\r\nexport function aStarNodesInShortestPath(endNode){\r\n    const shortestPath = [];\r\n    let currentNode = endNode;\r\n\r\n    while(currentNode !== null){\r\n        shortestPath.unshift(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n\r\n    return shortestPath;\r\n}","export function BFS(grid, startNode, endNode) {\r\n    startNode.isVisited = true;\r\n\r\n    const stack = [startNode],\r\n        visitedNodesInOrder = [];\r\n\r\n    while(stack[0] !== undefined){\r\n        const currentNode = stack.shift();\r\n        \r\n        visitedNodesInOrder.push(currentNode); //for animations\r\n\r\n        if(currentNode === endNode) break; \r\n\r\n        const neigbors = getUnvisitedNeighbors(currentNode, grid);\r\n        for(let i = 0; i < neigbors.length; i++){\r\n            neigbors[i].isVisited = true;\r\n            neigbors[i].previousNode = currentNode;\r\n            stack.push(neigbors[i]);\r\n        }\r\n    }\r\n\r\n    return visitedNodesInOrder;\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const {col, row} = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]); //UP\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]); //DOWN\r\n    if (col > 0) neighbors.push(grid[row][col - 1]); //LEFT\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]); //RIGHT\r\n    return neighbors.filter(neighbor => (!neighbor.isVisited && !neighbor.isWall));\r\n}","export function DFS(grid, startNode, endNode) {\r\n    startNode.isVisited = true;\r\n\r\n    const stack = [startNode],\r\n        visitedNodesInOrder = [];\r\n\r\n    while(stack[0] !== undefined){\r\n        const currentNode = stack.pop();\r\n        currentNode.isVisited = true;\r\n        \r\n        visitedNodesInOrder.push(currentNode); //for animations\r\n\r\n        if(currentNode === endNode) break; \r\n\r\n        const neigbors = getUnvisitedNeighbors(currentNode, grid);\r\n        for(let i = 0; i < neigbors.length; i++){\r\n            neigbors[i].previousNode = currentNode;\r\n            stack.push(neigbors[i]);\r\n        }\r\n    }\r\n\r\n    return visitedNodesInOrder;\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const {col, row} = node;\r\n    if (col > 0) neighbors.push(grid[row][col - 1]); //LEFT\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]); //DOWN\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]); //RIGHT\r\n    if (row > 0) neighbors.push(grid[row - 1][col]); //UP\r\n    return neighbors.filter(neighbor => (!neighbor.isVisited && !neighbor.isWall));\r\n}","export function BestFS(grid, startNode, endNode){\r\n    startNode.distance = 0;\r\n    const visitedNodesInOrder = [],\r\n        stack = [startNode];\r\n\r\n    while (!!stack.length) {\r\n        \r\n        sortNodesByDistance(stack);\r\n        const currentNode = stack.shift();\r\n\r\n        if (currentNode.distance === Infinity) break;\r\n\r\n        currentNode.isVisited = true;\r\n        visitedNodesInOrder.push(currentNode);\r\n\r\n        if (currentNode === endNode) break;\r\n        \r\n        const neigbors = getUnvisitedNeighbors(currentNode, grid);\r\n        for(let i = 0; i < neigbors.length; i++){\r\n            neigbors[i].previousNode = currentNode;\r\n            neigbors[i].isVisited = true;\r\n            neigbors[i].distance = heuristic(neigbors[i], endNode);\r\n            stack.push(neigbors[i]);\r\n        }\r\n\r\n    }\r\n\r\n    return visitedNodesInOrder;\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n    unvisitedNodes.sort((nodeA, nodeB) => (nodeA.distance) - (nodeB.distance));\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const {col, row} = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    return neighbors.filter(neighbor => !neighbor.isVisited && !neighbor.isWall);\r\n  }\r\n\r\n//Im basing the heuristic of the distance from the node Im \r\n//looking at to where its trying to go\r\nfunction heuristic(node, endNode){\r\n    let dist = 0;\r\n\r\n    dist += Math.abs(node.col - endNode.col);\r\n    dist += Math.abs(node.row - endNode.row);\r\n\r\n    return dist;\r\n}","export function recursiveMazeDivision(grid, x, y, width, height, animations){\r\n    if (width <= 2 || height <= 2) return;\r\n\r\n    //horizontal or vertical line\r\n    let horizontal;\r\n\r\n    if(width < height){\r\n        horizontal = true;\r\n    } else if(height < width){\r\n        horizontal = false;\r\n    } else {\r\n        horizontal = getRndInteger(0, 2) ? true : false;\r\n    }\r\n\r\n    //direction the wall is built in\r\n    let dx = horizontal ? 1 : 0,\r\n        dy = horizontal ? 0 : 1;\r\n    \r\n    //length of wall\r\n    let length = horizontal ? width : height;\r\n\r\n    //where the wall will be located\r\n    let wx = x + (horizontal ? 0 : getRndInteger(1, width-1)),\r\n        wy = y + (horizontal ? getRndInteger(1, height-1) : 0);\r\n    \r\n    //where the passage will be\r\n    let px = wx + (horizontal ? getRndInteger(0, width) : -1),\r\n        py = wy + (horizontal ? -1 : getRndInteger(0, height));\r\n    \r\n    //stops wall from blocking a previous passage\r\n    let passageBlocked = false\r\n    if(horizontal){\r\n        if(!grid[wy][wx+length].isWall){\r\n            px = wx+length-1;\r\n            passageBlocked = true;\r\n        }\r\n        if(!grid[wy][wx-1].isWall){\r\n            //double blocked passage\r\n            if(passageBlocked){\r\n                length -= 1;\r\n                wx += 1\r\n            } else {\r\n                px = wx;\r\n            }\r\n        }\r\n    } else {\r\n        if(!grid[wy+length][wx].isWall){\r\n            py = wy+length-1;\r\n            passageBlocked = true;\r\n        } \r\n        if(!grid[wy-1][wx].isWall){\r\n            //double blocked passage\r\n            if(passageBlocked){\r\n                length -= 1;\r\n                wy += 1\r\n            } else {\r\n                py = wy;\r\n            }\r\n        }\r\n    }\r\n\r\n    //building wall\r\n    for(let i = 0; i < length; i++){\r\n        //allow a spot for a passageway\r\n        if(wx !== px && wy !== py && !grid[wy][wx].isStart && !grid[wy][wx].isFinish){ \r\n            grid[wy][wx].isWall = true; \r\n            animations.push(grid[wy][wx]);\r\n        }\r\n        wx += dx;\r\n        wy += dy;\r\n    }\r\n\r\n    //up and left\r\n    let [nx, ny] = [x, y];\r\n    let [w, h] = horizontal ? [width, wy-y] : [wx-x, height];\r\n    //console.log([grid, nx, ny, w, h]);\r\n    recursiveMazeDivision(grid, nx, ny, w, h, animations);\r\n\r\n    //bottom and right\r\n    [nx, ny] = horizontal ? [x, wy+1] : [wx+1, y];\r\n    [w, h] = horizontal ? [width, y+height-wy-1] : [x+width-wx-1, height];\r\n    recursiveMazeDivision(grid, nx, ny, w, h, animations);\r\n}\r\n\r\nfunction getRndInteger(min, max) {\r\n    return Math.floor(Math.random() * (max - min) ) + min;\r\n}","import React from 'react'\r\nimport Node from './Node/Node'\r\nimport './PathFinding.css'\r\nimport { Navbar, Nav, Button, Form } from 'react-bootstrap'\r\nimport { HTML5Backend } from 'react-dnd-html5-backend'\r\nimport { DndProvider } from 'react-dnd'\r\nimport { dijkstra } from './algorithms/dijkstra'\r\nimport { aStar } from './algorithms/aStar'\r\nimport { BFS } from './algorithms/breadthFirstSearch'\r\nimport { DFS } from './algorithms/depthFirstSearch'\r\nimport { BestFS } from './algorithms/BestFS'\r\nimport { recursiveMazeDivision } from './mazeAlgorithms/recursiveDivsion'\r\n\r\nlet START_NODE_ROW = 0,\r\n    START_NODE_COL = 0,\r\n    END_NODE_ROW = 0,\r\n    END_NODE_COL = 0,\r\n    NODES_IN_COL = Math.floor(window.innerWidth/25)-2,\r\n    NODES_IN_ROW = Math.floor((window.innerHeight-200)/25)-1;\r\n\r\nexport default class PathFinding extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            grid: [],\r\n            mouseIsPressed: false,\r\n            disableBtn: false,\r\n        };\r\n    }\r\n\r\n    componentDidMount(){\r\n        this.initializeGrid(NODES_IN_COL, NODES_IN_ROW);\r\n    }\r\n\r\n    initializeGrid(width, height){\r\n        const grid = [];\r\n\r\n        START_NODE_ROW = Math.floor(height/2);\r\n        START_NODE_COL = Math.floor(width/4);\r\n        END_NODE_ROW = Math.floor(height/2);\r\n        END_NODE_COL = Math.floor(width/4)*3;\r\n              \r\n        for (let row = 0; row < height; row++) {\r\n            const currentRow = [];\r\n            for (let col = 0; col < width; col++) {\r\n                currentRow.push(this.createNode(col, row, false));\r\n            }\r\n            grid.push(currentRow);\r\n        }\r\n\r\n        this.setState({grid});\r\n    }\r\n\r\n    resizeGrid(){\r\n        NODES_IN_COL = Math.floor(window.innerWidth/25)-2;\r\n        NODES_IN_ROW = Math.floor((window.innerHeight-200)/25)-1;\r\n\r\n        this.initializeGrid(NODES_IN_COL, NODES_IN_ROW);\r\n    }\r\n\r\n    // *** MOUSE ***\r\n    handleMouseDown(row, col) {\r\n        //disable walls while animations are running\r\n        if(!this.state.disableBtn){\r\n        \r\n            this.setState({mouseIsPressed: true});\r\n            \r\n            let node = document.getElementById(`node-${row}-${col}`)\r\n            const nodeType = node.classList[node.classList.length - 1];\r\n\r\n            if(nodeType === \"node-wall\"){\r\n                node.className = 'node';\r\n            } else{\r\n                node.className = 'node node-wall';\r\n            }\r\n        }\r\n    }\r\n    \r\n    handleMouseEnter(row, col) {\r\n        if (!this.state.mouseIsPressed) return;\r\n        \r\n        let node = document.getElementById(`node-${row}-${col}`)\r\n        const nodeType = node.classList[node.classList.length - 1];\r\n        if(nodeType === \"node-wall\"){\r\n            node.className = 'node';\r\n        } else{\r\n            node.className = 'node node-wall';\r\n        }\r\n    }\r\n    \r\n    handleMouseUp() {\r\n        //I set grid once the user is done as opposed to setting the \r\n        //grid everytime a node gets turned to a wall\r\n        this.setGrid();\r\n        this.setState({mouseIsPressed: false});\r\n    }\r\n\r\n    // *** ANIMATION ***\r\n    animatePathFinding(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n        for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n            //After the algorithm has been visualised I then visualise the shortest path\r\n            if (i === visitedNodesInOrder.length) {\r\n                setTimeout(() => {\r\n                    this.animateShortestPath(nodesInShortestPathOrder);\r\n                }, 10 * i);\r\n                return;\r\n            }\r\n            //Visualizing the algorithm\r\n            setTimeout(() => {\r\n                const node = visitedNodesInOrder[i];\r\n\r\n                document.getElementById(`node-${node.row}-${node.col}`).className =\r\n                    'node node-visited';\r\n\r\n            }, 10 * i);\r\n        }\r\n    }\r\n    \r\n    animateShortestPath(nodesInShortestPathOrder) {\r\n        for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n            setTimeout(() => {\r\n                if(i === nodesInShortestPathOrder.length-1){\r\n                    this.setState({disableBtn: false});\r\n                }\r\n\r\n                const node = nodesInShortestPathOrder[i];\r\n\r\n                document.getElementById(`node-${node.row}-${node.col}`).className =\r\n                    'node node-shortest-path';\r\n                \r\n            }, 50 * i);\r\n        }\r\n    }\r\n\r\n    animateMazeBuilding(animations, grid){\r\n        for (let i = 0; i < animations.length; i++) {\r\n            setTimeout(() => {\r\n                if(i === 0){\r\n                    this.setState({disableBtn: true});\r\n                } else if(i === animations.length-1){\r\n                    this.setState({disableBtn: false});\r\n                }\r\n\r\n                const node = animations[i];\r\n\r\n                document.getElementById(`node-${node.row}-${node.col}`).className =\r\n                    'node node-wall';\r\n\r\n                //have to set it once it's done so animaions will go off\r\n                if(node === animations[animations.length-1]) this.setState({grid});\r\n                \r\n            }, 20 * i);\r\n        }\r\n    }\r\n\r\n    getShortestPath(endNode) {\r\n\r\n        const nodesInShortestPathOrder = [];\r\n        let currentNode = endNode;\r\n        while (currentNode !== null) {\r\n          //Adds new item to beginning of the array\r\n          nodesInShortestPathOrder.unshift(currentNode);\r\n          currentNode = currentNode.previousNode;\r\n        }\r\n      \r\n        return nodesInShortestPathOrder;\r\n    }\r\n\r\n    visualiseRecursiveMaze(){\r\n        //prepare board for maze\r\n        this.clearGrid();\r\n\r\n        const { grid } = this.state,\r\n              [width, height] = [NODES_IN_COL, NODES_IN_ROW],\r\n              animations = this.animateOuterWalls(width, height);\r\n\r\n        //adds more annimations to the array\r\n        recursiveMazeDivision(grid, 1, 1, width-2, height-2, animations);\r\n\r\n        this.animateMazeBuilding(animations, grid);\r\n    }\r\n\r\n    animateOuterWalls(w, h){\r\n        const { grid } = this.state;\r\n\r\n        const animations = [];\r\n\r\n        for(let i = 0; i < h; i++){\r\n            if(i === 0 || i === h-1){\r\n                for(let j = 0; j < w; j++){\r\n                    animations.push(grid[i][j]);\r\n                    grid[i][j].isWall = true;\r\n                }\r\n            } else {\r\n                animations.push(grid[i][0]);\r\n                animations.push(grid[i][w-1]);\r\n                grid[i][0].isWall = true;\r\n                grid[i][w-1].isWall = true;\r\n            }\r\n        }\r\n\r\n        return animations\r\n    }\r\n\r\n    // *** BOARD SETTINGS ***\r\n    clearGrid(){\r\n        const {grid} = this.state;\r\n\r\n        for(let row = 0; row < grid.length; row++){\r\n            for(let col = 0; col < grid[row].length; col++){\r\n\r\n                const node = document.getElementById(`node-${row}-${col}`)\r\n\r\n                //set to default values\r\n                grid[row][col].previousNode = null;\r\n                grid[row][col].isVisited = false;\r\n                grid[row][col].distance = Infinity;\r\n                grid[row][col].isWall = false;\r\n                \r\n                if(grid[row][col].isStart){\r\n                    node.className = 'node node-start';\r\n                } else if(grid[row][col].isFinish){\r\n                    node.className = 'node node-finish';\r\n                } else {\r\n                    node.className ='node';\r\n                }\r\n            }\r\n        }\r\n        \r\n        this.initializeGrid(NODES_IN_COL, NODES_IN_ROW);\r\n    }\r\n\r\n    clearVisitedNodes(){\r\n        const {grid} = this.state;\r\n\r\n        for(let row = 0; row < grid.length; row++){\r\n            for(let col = 0; col < grid[row].length; col++){\r\n\r\n                //the onscreen node that the user can see\r\n                const node = document.getElementById(`node-${row}-${col}`)\r\n\r\n                //the node behind the scene\r\n                //resetting node\r\n                grid[row][col].previousNode = null;\r\n                grid[row][col].isVisited = false;\r\n                grid[row][col].distance = Infinity;\r\n                \r\n                if(grid[row][col].isStart){\r\n                    node.className = 'node node-start';\r\n                } else if(grid[row][col].isFinish){\r\n                    node.className = 'node node-finish';\r\n                }\r\n                else if(!grid[row][col].isWall){\r\n                    node.className = 'node';\r\n                }\r\n            }\r\n        }\r\n        \r\n        this.setState({grid});\r\n    }\r\n\r\n    createNode(col, row, iswall){\r\n        return {\r\n            col,\r\n            row,\r\n            isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n            isFinish: row === END_NODE_ROW && col === END_NODE_COL,\r\n            distance: Infinity,\r\n            isVisited: false,\r\n            isWall: iswall,\r\n            previousNode: null,\r\n        };\r\n    };\r\n\r\n    setGrid(){\r\n        const grid = [];\r\n\r\n        for(let row = 0; row < NODES_IN_ROW; row++){\r\n            const currentRow = [];\r\n             for(let col = 0; col < NODES_IN_COL; col++){\r\n                \r\n                const idName = \"node-\"+row.toString()+\"-\"+col.toString();\r\n                let node = document.getElementById(idName);\r\n\r\n                const classList = node.classList;\r\n                //the last class is what type of node it is\r\n                const nodeType = classList[classList.length - 1];\r\n\r\n                if(nodeType === \"node-wall\"){\r\n                    currentRow.push(this.createNode(col, row, true));\r\n                } else {\r\n                    currentRow.push(this.createNode(col, row, false));\r\n                }\r\n            }\r\n            grid.push(currentRow);\r\n        }\r\n        \r\n        this.setState({grid});\r\n    }\r\n\r\n    selectAlgorithm(){\r\n        const algorithm = document.getElementById('algorithmSelect').value;\r\n\r\n        if(algorithm !== \"Pick an algorithm\"){\r\n            this.clearVisitedNodes();\r\n\r\n            //Gets variables\r\n            const { grid } = this.state,\r\n                startNode = grid[START_NODE_ROW][START_NODE_COL],\r\n                endNode = grid[END_NODE_ROW][END_NODE_COL];\r\n            \r\n            let visitedNodesInOrder = null,\r\n                nodesInShortestPathOrder = null;\r\n\r\n            //Reduces some initial lag\r\n            this.setState({disableBtn: true});\r\n\r\n            if(algorithm === \"Dijkstra\"){\r\n\r\n                visitedNodesInOrder = dijkstra(grid, startNode, endNode);\r\n\r\n            } else if(algorithm === \"A*\"){\r\n                \r\n                visitedNodesInOrder = aStar(grid, startNode, endNode);\r\n\r\n            } else if(algorithm === \"Breadth-First-Search\"){\r\n                \r\n                visitedNodesInOrder = BFS(grid, startNode, endNode);\r\n\r\n            } else if(algorithm === \"Depth-First-Search\"){\r\n                \r\n                visitedNodesInOrder = DFS(grid, startNode, endNode);\r\n\r\n            } else if(algorithm === \"Best-First-Search\"){\r\n                \r\n                visitedNodesInOrder = BestFS(grid, startNode, endNode);\r\n\r\n            }\r\n\r\n            nodesInShortestPathOrder = this.getShortestPath(endNode);\r\n\r\n            this.animatePathFinding(visitedNodesInOrder, nodesInShortestPathOrder)\r\n        }\r\n    }\r\n\r\n    selectMazeAlgorithm(){\r\n        const algorithm = document.getElementById('mazeAlgorithmSelect').value;\r\n\r\n        this.clearGrid();\r\n\r\n        if(algorithm === \"Recursive Maze Division\"){\r\n            this.visualiseRecursiveMaze();\r\n        }\r\n    }\r\n\r\n    changeBtnText(type){\r\n        //For Path Algorithms\r\n        let algorithmName = document.getElementById('algorithmSelect').value;\r\n        if(algorithmName === \"Pick an algorithm\"){\r\n            algorithmName = \"\";\r\n        }\r\n        document.querySelector('#btnSort').innerHTML = algorithmName + \" Sort\";\r\n        \r\n    }\r\n\r\n    moveNode(node){\r\n        console.log(node);\r\n    }\r\n\r\n    render(){\r\n        const { grid, disableBtn } = this.state;\r\n\r\n        return(\r\n            <DndProvider backend={HTML5Backend}>\r\n                <h2 className=\"text-center bg-dark m-0 py-2 text-white\">\r\n                    <a href=\"../../\" id=\"title\">Billy Dyball - Path Visualization</a>\r\n                </h2>\r\n                <Navbar collapseOnSelect expand=\"lg\" bg=\"dark\" variant=\"dark\" >\r\n                    <Navbar.Toggle aria-controls=\"responsive-navbar-nav\" />\r\n                    <Navbar.Collapse id=\"responsive-navbar-nav\">\r\n                        <Nav className=\"navbar-collapse flex-lg-column\">\r\n\r\n                            <div className=\"groupTitle row\">Maze Selection</div>\r\n                            <div className=\"row\">\r\n                                <Form>\r\n                                    <Form.Control \r\n                                        as=\"select\" \r\n                                        id=\"mazeAlgorithmSelect\" \r\n                                        disabled={disableBtn}\r\n                                    >\r\n                                        <option>Pick a maze algorithm</option>\r\n                                        <option>Recursive Maze Division</option>\r\n                                    </Form.Control>\r\n                                </Form>\r\n                                <Button \r\n                                    onClick={() => this.selectMazeAlgorithm(\"maze\")} \r\n                                    id=\"btnMazeSort\" \r\n                                    disabled={disableBtn}>Run Maze</Button>\r\n                            </div>\r\n\r\n                        </Nav>\r\n                        <Nav className=\"navbar-collapse flex-lg-column groupCenter\">\r\n\r\n                            <div className=\"groupTitle row\">Algorithm Sort</div>\r\n                            <div className=\"row\">\r\n                                <Form>\r\n                                    <Form.Control \r\n                                        as=\"select\" \r\n                                        id=\"algorithmSelect\" \r\n                                        onChange={() => this.changeBtnText()} \r\n                                        disabled={disableBtn}\r\n                                    >\r\n                                        <option>Pick an algorithm</option>\r\n                                        <option>A*</option>\r\n                                        <option>Breadth-First-Search</option>\r\n                                        <option>Best-First-Search</option>\r\n                                        <option>Depth-First-Search</option>\r\n                                        <option>Dijkstra</option>\r\n                                    </Form.Control>\r\n                                </Form>\r\n                                <Button \r\n                                    onClick={() => this.selectAlgorithm()} \r\n                                    id=\"btnSort\" \r\n                                    disabled={disableBtn}>Sort</Button>\r\n                            </div>\r\n\r\n                        </Nav>\r\n                        <Nav className=\"navbar-collapse flex-lg-column\">\r\n\r\n                            <div className=\"groupTitle row\">Board Settings</div>\r\n                            <div>\r\n                                <Button \r\n                                    onClick={() => this.clearGrid()} \r\n                                    disabled={disableBtn}>Clear Board</Button>\r\n                                <Button \r\n                                    onClick={() => this.clearVisitedNodes()} \r\n                                    disabled={disableBtn}>clear Visited Nodes</Button>\r\n                            </div>\r\n\r\n                        </Nav>\r\n                    </Navbar.Collapse>\r\n                </Navbar>\r\n                <div className=\"grid mx-auto\">\r\n                    {grid.map((row, rowIdx) => {\r\n                        return (\r\n                        <div \r\n                            key={rowIdx} \r\n                            style={{ width: 25*row.length,\r\n                                    height: 25,\r\n                            }}>\r\n                            {row.map((node, nodeIdx) => {\r\n                                const { row, col, isFinish, isStart, isWall } = node;\r\n                                return (\r\n                                    <Node\r\n                                    key={nodeIdx}\r\n                                    row={row}\r\n                                    col={col}\r\n                                    isFinish={isFinish}\r\n                                    isStart={isStart}\r\n                                    isWall={isWall}\r\n                                    onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                                    onMouseEnter={(row, col) =>\r\n                                        this.handleMouseEnter(row, col)\r\n                                    }\r\n                                    onMouseUp={() => this.handleMouseUp()}\r\n                                    handleDrop={(node) => this.moveNode(node)}></Node>\r\n                                );\r\n                            })}\r\n                        </div>\r\n                        );\r\n                    })}\r\n                </div>\r\n            </DndProvider>\r\n        );\r\n    }\r\n}","import React from 'react';\nimport logo from './logo.svg';\nimport PathFinding from './PathFinding/PathFinding';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport './App.css';\n\nfunction App() {\n  return (\n    <PathFinding></PathFinding>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}